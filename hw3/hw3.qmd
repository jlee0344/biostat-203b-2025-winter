---
title: "Biostat 203B Homework 3"
subtitle: "Due Feb 21 @ 11:59PM"
author: "Julie Lee, 806409381"
format:
  html:
    theme: cosmo
    embed-resources: true
    number-sections: false
    toc: true
    toc-depth: 4
    toc-location: left
    code-fold: false
---

Display machine information for reproducibility:
```{r}
sessionInfo()
```

Load necessary libraries (you can add more as needed).
```{r setup}
library(arrow)
library(gtsummary)
library(memuse)
library(pryr)
library(R.utils)
library(tidyverse)
library(duckdb)
```

Display your machine memory.
```{r}
memuse::Sys.meminfo()
```

In this exercise, we use tidyverse (ggplot2, dplyr, etc) to explore the [MIMIC-IV](https://physionet.org/content/mimiciv/3.1/) data introduced in [homework 1](https://ucla-biostat-203b.github.io/2025winter/hw/hw1/hw1.html) and to build a cohort of ICU stays.

## Q1. Visualizing patient trajectory

Visualizing a patient's encounters in a health care system is a common task in clinical data analysis. In this question, we will visualize a patient's ADT (admission-discharge-transfer) history and ICU vitals in the MIMIC-IV data.

### Q1.1 ADT history

A patient's ADT history records the time of admission, discharge, and transfer in the hospital. This figure shows the ADT history of the patient with `subject_id` 10001217 in the MIMIC-IV data. The x-axis is the calendar time, and the y-axis is the type of event (ADT, lab, procedure). The color of the line segment represents the care unit. The size of the line segment represents whether the care unit is an ICU/CCU. The crosses represent lab events, and the shape of the dots represents the type of procedure. The title of the figure shows the patient's demographic information and the subtitle shows top 3 diagnoses.

![](10001217_adt.png)
Do a similar visualization for the patient with `subject_id` 10063848 using ggplot.

Hint: We need to pull information from data files `patients.csv.gz`, `admissions.csv.gz`, `transfers.csv.gz`, `labevents.csv.gz`, `procedures_icd.csv.gz`, `diagnoses_icd.csv.gz`, `d_icd_procedures.csv.gz`, and `d_icd_diagnoses.csv.gz`. For the big file `labevents.csv.gz`, use the Parquet format you generated in Homework 2. For reproducibility, make the Parquet folder `labevents_pq` available at the current working directory `hw3`, for example, by a symbolic link. Make your code reproducible.

```{bash}
ln -s ~/biostat-203b-2025-winter/hw2/labevents_parquet ./labevents_pq
ls -l ./labevents_pq
```

```{bash}
ln -s ~/biostat-203b-2025-winter/hw2/chartevents_parquet ./chartevents_pq
ls -l ./chartevents_pq
```

```{r}
patients <- read_csv("~/mimic/hosp/patients.csv.gz")
admissions <- read_csv("~/mimic/hosp/admissions.csv.gz")
transfers <- read_csv("~/mimic/hosp/transfers.csv.gz")
labevents <- read_parquet("labevents_pq/part-0.parquet")
procedures <- read_csv("~/mimic/hosp/procedures_icd.csv.gz")
diagnoses <- read_csv("~/mimic/hosp/diagnoses_icd.csv.gz")
d_icd_procedures <- read_csv("~/mimic/hosp/d_icd_procedures.csv.gz")
d_icd_diagnoses <- read_csv("~/mimic/hosp/d_icd_diagnoses.csv.gz")
icustays <- read_csv("~/mimic/icu/icustays.csv.gz")
d_items <- read_csv("~/mimic/icu/d_items.csv.gz")
```

```{r}
# Filter data for patient 10063848
subject_id <- 10063848
patient_info <- patients %>% filter(subject_id == !!subject_id)
admissions_info <- admissions %>% filter(subject_id == !!subject_id)
transfers_info <- transfers %>% filter(subject_id == !!subject_id)
labevents_info <- labevents %>% filter(subject_id == !!subject_id)
procedures_info <- procedures %>% filter(subject_id == !!subject_id)
diagnoses_info <- diagnoses %>% filter(subject_id == !!subject_id)
d_icd_procedures_info <- d_icd_procedures %>% filter(subject_id == !!subject_id)
d_icd_diagnoses_info <- d_icd_diagnoses %>% filter(subject_id == !!subject_id)
icustays_info <- icustays %>% filter(subject_id == !!subject_id)
d_items_info <- d_items %>% filter(subject_id == !!subject_id)
```

```{r}
diagnoses_info <- diagnoses_info %>%
  mutate(icd_code = str_pad(icd_code, width = 5, pad = "0"))

diagnoses_info <- diagnoses_info %>% 
  left_join(d_icd_diagnoses, by = c("icd_code", "icd_version"))

# Identify the correct long_title column for diagnoses
long_title_col <- grep("long_title", colnames(diagnoses_info), value = TRUE)

if ("long_title" %in% long_title_col) {
  diagnoses_info <- diagnoses_info %>% rename(diagnosis_name = long_title)
} else if ("long_title.x" %in% long_title_col) {
  diagnoses_info <- diagnoses_info %>% rename(diagnosis_name = long_title.x)
} else if ("long_title.y" %in% long_title_col) {
  diagnoses_info <- diagnoses_info %>% rename(diagnosis_name = long_title.y)
} else {
  stop("long_title column not found in diagnoses_info")
}

# Extract top 3 diagnoses, removing NA values
top_diagnoses <- diagnoses_info %>% 
  filter(!is.na(diagnosis_name)) %>% 
  count(diagnosis_name, sort = TRUE) %>%  
  slice_head(n = 3) %>% 
  pull(diagnosis_name)

# Format diagnoses for display
top_diagnoses_text <- ifelse(length(top_diagnoses) > 0,
  paste(top_diagnoses, collapse = "\n"), "")

# Construct patient summary
patient_summary <- str_squish(str_c(
  "Patient ", patient_info, ", ",
  case_when(is.na(patient_info$gender) ~ "", TRUE ~ str_c(patient_info$gender, ", ")),
  case_when(is.na(patient_info$anchor_age) ~ "", TRUE ~ str_c(patient_info$anchor_age, " years old, ")),
  case_when(is.na(admissions_info$race) ~ "", TRUE ~ admissions_info$race)
))

# Convert timestamps
transfers_info <- transfers_info %>%
  mutate(intime = as.POSIXct(intime, format="%Y-%m-%d %H:%M:%S"),
         outtime = as.POSIXct(outtime, format="%Y-%m-%d %H:%M:%S")) %>%
  filter(!is.na(outtime))  

labevents_info <- labevents_info %>%
  mutate(chartdate = as.POSIXct(charttime, format="%Y-%m-%d %H:%M:%S"))

# Join and resolve duplicate columns in procedures_info
procedures_info <- procedures_info %>%
  mutate(chartdate = as.POSIXct(chartdate, format="%Y-%m-%d %H:%M:%S")) %>%
  left_join(d_icd_procedures, by = c("icd_code", "icd_version"))

# Identify procedure name columns
procedure_name_cols <- grep("long_title", colnames(procedures_info), value = TRUE)

# Ensure only one unique procedure_name remains
if (length(procedure_name_cols) > 1) {
  procedures_info <- procedures_info %>% 
  select(-one_of(procedure_name_cols[-1])) %>% 
  rename(procedure_name = procedure_name_cols[1])
} else if (length(procedure_name_cols) == 1) {
  procedures_info <- procedures_info %>%
  rename(procedure_name = procedure_name_cols[1])
} else {
  stop("procedure_name column not found in procedures_info")
}

# Remove rows where procedure_name is missing
procedures_info <- procedures_info %>% filter(!is.na(procedure_name))

### **Dynamically Extract Unique Care Units** ###
unique_care_units <- unique(transfers_info$careunit)

# Dynamically generate colors for care units
care_unit_colors <- setNames(
  RColorBrewer::brewer.pal(n = min(length(unique_care_units), 9), name = "Set1"),  
  unique_care_units
)

# Ensure Care Unit Column is a Factor with Correct Levels
transfers_info <- transfers_info %>%
  mutate(careunit = factor(careunit, levels = unique_care_units))  

### **Dynamically Extract Unique Procedures** ###
unique_procedures <- unique(procedures_info$procedure_name)

# Ensure Procedures Have Unique Shapes
procedure_shapes <- setNames(
  seq(15, 15 + length(unique_procedures) - 1),
  unique_procedures
)

procedures_info <- procedures_info %>%
  mutate(procedure_name = factor(procedure_name, levels = unique_procedures))

### **Plot Patient Trajectory** ###
plot <- ggplot() +
  geom_segment(data = transfers_info, 
               aes(x = intime, xend = outtime,
                   y = "ADT", yend = "ADT", color = careunit), 
               linewidth = 3) +
  geom_point(data = labevents_info, 
             aes(x = chartdate, y = "Lab"), shape = 3, size = 3) +
  geom_point(data = procedures_info, 
             aes(x = chartdate, y = "Procedure", shape = procedure_name), size = 5) +
  scale_color_manual(values = care_unit_colors) +  
  scale_shape_manual(values = procedure_shapes, drop = FALSE) + 
  scale_y_discrete(limits = c("Procedure", "Lab", "ADT")) +  
  theme_minimal() +
  labs(title = patient_summary, 
       subtitle = top_diagnoses_text, 
       x = "Calendar Time", 
       y = NULL, 
       color = "Care Unit", 
       shape = "Procedure") +
  guides(
    color = guide_legend(order = 1, title.position = "top"),  
    shape = guide_legend(order = 2, title.position = "top")   
  ) +
  theme(
    legend.position = "bottom",
    legend.box = "vertical",
    legend.box.just = "center",
    legend.spacing.y = unit(0.5, "cm"),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 10)
  )

print(plot)

```

**1.2** 
change time zone of charttime  from US (-7) to UTC to match other two time variables

Select stay_id as well in the filtered chartevent and save it in hw3 folder. Or keep the filtered chartevent generated in hw2 without stay_id and use charttime in chartevent and intime outtime in icustays table to keep only values during each stay
subject_id ⊃ hadm_id ⊃ stay_id, meaning that, for example, using select(subject_id, stay_id ) and join by both is equivalent to select(-subject_id, stay_id ) and join by stay_id etc.

**Solution ** Note that the dataset that I selected is the filtered chart_events parquet file that was created in Homework #2 with the modification of adding in stay_id as well as including the item_id "Diastolic Non-invasive blood pressure (2210180) instead of mean non-invasive blood pressure (2200181). 

```{r}
subset_chartevents
```


```{r}
## Q2. ICU stays
`icustays.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/icu/icustays/>) contains data about Intensive Care Units (ICU) stays. The first 10 lines are
```{bash}
zcat < ~/mimic/icu/icustays.csv.gz | head
```

### Q2.1 Ingestion

Import `icustays.csv.gz` as a tibble `icustays_tble`. **Done** 

```{r}
icustays_tble <- read_csv("~/mimic/icu/icustays.csv.gz")
head(icustays_tble)
```

### Q2.2 Summary and visualization

How many unique `subject_id`? Can a `subject_id` have multiple ICU stays? Summarize the number of ICU stays per `subject_id` by graphs. 

**(2.2) Solution ** 

The number of unique subject_id there are in the (icustays_tble) tibble is 65366 unique subjects. 
```{r}
# Count unique subject_id
num_unique_subjects <- icustays_tble %>% 
  distinct(subject_id) %>% 
  nrow()

print(paste(num_unique_subjects))
```

A subject_id can have multiple ICU stays. We first obtained a tibble with the number of ICU stays per subject_id. Next we filtered out the rows where the subjects only had 1 ICU stay and counted the number of remaining rows. The number of patients with multiple ICU stays is 16242. 

```{r}
icu_stays_per_subject <- icustays_tble %>% 
  count(subject_id, name = "num_stays")

num_multiple_stays <- icu_stays_per_subject %>%
  filter(num_stays > 1) %>%
  nrow()

print(paste(num_multiple_stays))
```

The number of ICU stays per 'subject_id' is shown through the following graphs: 

1. Depicted below is a bar graph that displays the number of ICU stays for the top 20 pateints with the most ICU stays. We can see that the maximum number of ICU stays amongst these 20 individuals ranges from between 19 to 41 ICU stays (including admission and discharge times). The general range of ICU stays is 1-41 stays. 

```{r}
# Summarize ICU stays per subject_id efficiently
icu_stays_summary <- icustays_tble %>%
  group_by(subject_id) %>%
  summarise(num_stays = n(), .groups = 'drop')

top_patients <- icu_stays_summary %>%
  arrange(desc(num_stays)) %>%
  head(20)

ggplot(top_patients, aes(x = reorder(subject_id, num_stays), y = num_stays)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(title = "Top 20 Patients with Most ICU Stays",
       x = "Subject ID",
       y = "Number of ICU Stays") +
  theme_minimal()
```

2. Below is a graph that visualizes the number of ICU stays per subject_id, with patients sorted in ascending order by the number of stays (each subject_id or patient is ranked starting from 1 depending on how many ICU stays they have). The visualization employs a color-coded scatter plot to distinguish different groups of ICU stays. Patients are grouped based on the number of ICU stays: 1. 1-8 stays (blue), 2. 9-16 stays (green), 3. 17-24 stays (orange), 4. 25-32 stays (red), 5. 33-41 stays (purple). From the scatter plot, we observe that the majority of points are blue, indicating that most patients fall within the 1-8 ICU stays range. This suggests that ICU stays are generally short for most patients. However, towards the right of the graph, the number of ICU stays increases steeply, forming a long-tail distribution. This pattern indicates that a small number of patients experience significantly higher ICU admissions. Overall, the distribution follows a right-skewed pattern, where most patients have a low ICU stay count, while a few patients have disproportionately high ICU stays. 

```{r}
# Summarize ICU stays per subject_id
icu_stays_summary <- icustays_tble %>%
  group_by(subject_id) %>%
  summarise(num_stays = n(), .groups = 'drop')

# Define 5 groups based on ICU stay ranges
icu_stays_summary <- icu_stays_summary %>%
  mutate(stay_group = case_when(
    num_stays >= 1  & num_stays <= 8  ~ "1-8 stays",
    num_stays >= 9  & num_stays <= 16 ~ "9-16 stays",
    num_stays >= 17 & num_stays <= 24 ~ "17-24 stays",
    num_stays >= 25 & num_stays <= 32 ~ "25-32 stays",
    num_stays >= 33 & num_stays <= 41 ~ "33-41 stays"
  ))

# Order data by number of stays for better visualization
icu_stays_summary <- icu_stays_summary %>%
  arrange(num_stays)

# Assign numeric index for x-axis
icu_stays_summary <- icu_stays_summary %>%
  mutate(patient_index = row_number())

# Plot: Color-coded scatter plot of patients by ICU stay group
ggplot(icu_stays_summary, aes(x = patient_index, y = num_stays, color = stay_group)) +
  geom_point(alpha = 0.6, size = 2) + 
  labs(title = "ICU Stays per Subject (Grouped by Number of Stays)",
       x = "Patients (Sorted by ICU Stays)",
       y = "Number of ICU Stays",
       color = "ICU Stay Group") +
  theme_minimal() +
  scale_color_manual(values = c("blue", "green", "orange", "red", "purple"))
```

3. This graph provides similar information from the one above. The scatter plot visualzies the nummber of ICU stays per subject, using the specific specific id of each patient on the x-axis and the number of ICU stays on the y-axis. Each patient is categorized into different ICU stay groups, represented by distinct colors. The majority of patients have few ICU stays (1-8 stays) as depicted in blue. There is a small subset of patients that require frequent ICU visits as depicted in other colors other than blue. 

```{r}
# Summarize ICU stays per subject_id
icu_stays_summary <- icustays_tble %>%
  group_by(subject_id) %>%
  summarise(num_stays = n(), .groups = 'drop')

# Define 5 groups based on ICU stay ranges
icu_stays_summary <- icu_stays_summary %>%
  mutate(stay_group = case_when(
    num_stays >= 1  & num_stays <= 8  ~ "1-8 stays",
    num_stays >= 9  & num_stays <= 16 ~ "9-16 stays",
    num_stays >= 17 & num_stays <= 24 ~ "17-24 stays",
    num_stays >= 25 & num_stays <= 32 ~ "25-32 stays",
    num_stays >= 33 & num_stays <= 41 ~ "33-41 stays"
  ))

# Plot: Color-coded scatter plot of patients by ICU stay group (keeping original subject_id order)
ggplot(icu_stays_summary, aes(x = subject_id, y = num_stays, color = stay_group)) +
  geom_point(alpha = 0.6, size = 2) + 
  labs(title = "ICU Stays per Subject (Using Subject ID on X-Axis)",
       x = "Subject ID",
       y = "Number of ICU Stays",
       color = "ICU Stay Group") +
  theme_minimal() +
  scale_color_manual(values = c("blue", "green", "orange", "red", "purple"))  # Assigning colors

```

## Q3. `admissions` data

Information of the patients admitted into hospital is available in `admissions.csv.gz`. See <https://mimic.mit.edu/docs/iv/modules/hosp/admissions/> for details of each field in this file. The first 10 lines are

```{bash}
zcat < ~/mimic/hosp/admissions.csv.gz | head
```

### Q3.1 Ingestion

Import `admissions.csv.gz` as a tibble `admissions_tble`. **Done** 

```{r}
admissions_tble <- read_csv("~/mimic/hosp/admissions.csv.gz")
print(admissions_tble)
```

**(3.1 Solution) ** The admission_tble tibble has 546,028 rows and 16 columns. 

### Q3.2 Summary and visualization

Summarize the following information by graphics and explain any patterns you see.

1. Number of admissions per patient 

**Analysis:** The histogram illustrates the distribution of hospital admissions per patient on a log scale. The x-axis (log-transformed) represents the number of admissions per patient, while the y-axis represents the number of patients. From the histogram, we observe that the majority of patients have only 1-3 admissions, indicating that most individuals require minimal hospital visits. However, a small subset of patients exhibit significantly higher admission counts, with some exceeding 10+ admissions. Notably, a few extreme cases surpass 200 admissions, highlighting a group of patients with frequent and recurrent hospitalizations. 

```{r}
admissions_summary <- admissions_tble %>%
  group_by(subject_id) %>%
  summarise(num_admissions = n(), .groups = 'drop')

# Histogram with more bins and improved log scale
ggplot(admissions_summary, aes(x = num_admissions)) +
  geom_histogram(binwidth = 0.5, fill = "steelblue", color = "black", alpha = 0.8) +  # Smaller bin width
  scale_x_continuous(trans = "log1p", breaks = c(1, 2, 3, 5, 10, 15, 20, 30, 50, 100, 200)) +  # Finer x-axis detail
  labs(title = "Distribution of Admissions per Patient",
       x = "Number of Admissions (Log Scale)",
       y = "Number of Patients") +
  theme_minimal()
```

2. Admission hour (anything unusual?)  

**Analysis ** 
There is a high sharp spike at Midnight (00:00) which is likely not a true clinical pattern by rather an artifact of hospital data entry practices, such as batch processing of admissions at the start of a new day. The second peak occurs around 7-8 AM which may reflect morning clinical assessments leading to ICU transfers. Admissions then gradually rise throughout the day, peaking between 4-8 PM. 

```{r}
admissions_tble <- admissions_tble %>%
  mutate(admit_hour = hour(admittime))  # Extract hour from POSIXct datetime

ggplot(admissions_tble, aes(x = admit_hour)) +
  geom_histogram(binwidth = 1, fill = "steelblue", color = "black", alpha = 0.8) +
  scale_x_continuous(breaks = seq(0, 23, by = 1)) +  # Ensure all hours are visible
  labs(title = "Distribution of ICU Admissions by Hour",
       x = "Hour of Admission (24-hour format)",
       y = "Number of Admissions") +
  theme_minimal()
```

3. Admission minute (anything unusual?)  

**Analysis:** 
The histogram displays the distriution of ICU admission by the minute of the hour (0-59). There are sharp pikes in admissions at minutes 0,15,30,and 45 minutes, which are significantly higher than the other minutes. This suggests that admissions are often recorded at roudned times rather than exact times when paitnets arrive. This pattern is unlikely because there would be natural variations in patient arrivals. Instead, it could be a result of the hospital staff rounding admission times when entering data. Apart from the spikes, the distribution across other minutes is relatively uniform, signifying that the real admission times likely occur throughout the hou but are being recorded in a biased manner. 

```{r}
admissions_tble <- admissions_tble %>%
  mutate(admit_minute = minute(admittime))  # Extract minute from POSIXct datetime

ggplot(admissions_tble, aes(x = admit_minute)) +
  geom_histogram(binwidth = 1, fill = "darkorange", color = "black", alpha = 0.8) +
  scale_x_continuous(breaks = seq(0, 59, by = 5)) +  # Ensure visibility for all minutes
  labs(title = "Distribution of ICU Admissions by Minute",
       x = "Minute of Admission (0-59)",
       y = "Number of Admissions") +
  theme_minimal()
```

4. Length of hospital stay (from admission to discharge) (anything unusual?)  

**Analysis** 

The histogram visualizes the distribution of hospital length of stay, capped at 30 days.There is an unusually high number of 1-day stays, far exceeding other lengths, which may indicate short-term admissions, observation cases, or administrative coding practices. A notable concentration of patients at exactly 30 days suggests policy-driven discharge patterns or dataset truncation. The red density curve extends close to 30 days rather than sharply declining, indicating a subset of patients with prolonged hospitalizations, likely due to chronic conditions or severe cases.

```{r}
# Focus on hospital stays of 30 days or less
short_stays <- admissions_tble %>%
  filter(length_of_stay <= 30)

# Refined histogram with density overlay
ggplot(short_stays, aes(x = length_of_stay)) +
  geom_histogram(binwidth = 1, fill = "steelblue", color = "black", alpha = 0.8) +
  geom_density(color = "red", size = 1, alpha = 0.6) +
  scale_x_continuous(breaks = seq(0, 30, by = 5)) +
  labs(title = "Distribution of Hospital Length of Stay (≤ 30 Days)",
       x = "Length of Stay (Days)",
       y = "Number of Patients") +
  theme_minimal()
```

According to the [MIMIC-IV documentation](https://mimic.mit.edu/docs/iv/about/concepts/#date-shifting), 

> All dates in the database have been shifted to protect patient confidentiality. Dates will be internally consistent for the same patient, but randomly distributed in the future. Dates of birth which occur in the present time are not true dates of birth. Furthermore, dates of birth which occur before the year 1900 occur if the patient is older than 89. In these cases, the patient’s age at their first admission has been fixed to 300.

## Q4. `patients` data

Patient information is available in `patients.csv.gz`. See <https://mimic.mit.edu/docs/iv/modules/hosp/patients/> for details of each field in this file. The first 10 lines are: 

```{bash}
zcat < ~/mimic/hosp/patients.csv.gz | head
```

### Q4.1 Ingestion

Import `patients.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/hosp/patients/>) as a tibble `patients_tble`.

```{r}
patients_tble <- read_csv("~/mimic/hosp/patients.csv.gz")
print(patients_tble)
```

### Q4.2 Summary and visualization

Summarize variables `gender` and `anchor_age` by graphics, and explain any patterns you see.

**Summary Graph of Gender (genotypical sex of the patient): ** 
The bar chart illustrates the gender distribution of patients, showing a slight female majority. While females are more frequent than males, the difference is not substantial, indicating a fairly balanced representation of both genders in the dataset.

```{r}
# Bar Plot: Gender Distribution with Custom Colors
ggplot(patients_tble, aes(x = gender, fill = gender)) +
  geom_bar(color = "black", alpha = 0.8) +
  scale_fill_manual(values = c("M" = "steelblue", "F" = "pink")) +  # Assign colors
  labs(title = "Gender Distribution",
       x = "Gender",
       y = "Count of Patients") +
  theme_minimal()

```


**Summary Graph of Ancho_Age: ** 

Anchor_age represents a patient's age in the anchor_year. If a patient is over 89 years old, their anchor_age is set to 91, regardless of their actual age. The histogram depicts the age distribution of patients, showing a right-skewed pattern. Younger patients (under 25) make up the largest group. The number of patients gradually declines with age, though there is a slight increase around ages 45-65. Fewer patients are observed in older age groups (75+ years), which aligns with natural aging and mortality trends.

```{r}
# 2. Histogram: Age Distribution
ggplot(patients_tble, aes(x = anchor_age)) +
  geom_histogram(binwidth = 5, fill = "steelblue", color = "black", alpha = 0.8) +
  labs(title = "Age Distribution of Patients",
       x = "Age (Years)",
       y = "Number of Patients") +
  theme_minimal()
```

**Visualizing the 2 variables together: Gender and Anchor_Age: ** 
The box plot visualizes the age distribution of patients by genders, females and males. The median age is nearly the same for both genders, suggesting no significiant 

```{r}
# 3. Box Plot: Age by Gender
ggplot(patients_tble, aes(x = gender, y = anchor_age, fill = gender)) +
  geom_boxplot(alpha = 0.8) +
  labs(title = "Age Distribution by Gender",
       x = "Gender",
       y = "Age (Years)") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "pink"))  # Custom colors for M & F
```

## Q5. Lab results

`labevents.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/hosp/labevents/>) contains all laboratory measurements for patients. The first 10 lines are

```{bash}
zcat < ~/mimic/hosp/labevents.csv.gz | head
```

`d_labitems.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/hosp/d_labitems/>) is the dictionary of lab measurements. 
```{bash}
zcat < ~/mimic/hosp/d_labitems.csv.gz | head
```

We are interested in the lab measurements of creatinine (50912), potassium (50971), sodium (50983), chloride (50902), bicarbonate (50882), hematocrit (51221), white blood cell count (51301), and glucose (50931). Retrieve a subset of `labevents.csv.gz` that only containing these items for the patients in `icustays_tble`. Further restrict to the last available measurement (by `storetime`) before the ICU stay. The final `labevents_tble` should have one row per ICU stay and columns for each lab measurement.

![](labevents_tble.png)
We will use the Parquet format that I generated in Homework #2. For reproducibility, the labevents_pq folder is available at the current working directory by a symbolic link: 

```{bash}
ls -l ./labevents_pq
```

Hint: Use the Parquet format you generated in Homework 2. For reproducibility, make `labevents_pq` folder available at the current working directory `hw3`, for example, by a symbolic link.

```{r}
library(duckdb)
parquet_file <- "labevents_pq/part-0.parquet"
start_time <- Sys.time()
arrow_data <- open_dataset(parquet_file, format = "parquet")
duckdb_conn <- dbConnect(duckdb::duckdb())

invisible(to_duckdb(
  .data = arrow_data,
  con = duckdb_conn,
  table_name = "labevents",
  auto_disconnect = FALSE
))  

subset_labevents <- tbl(duckdb_conn, "labevents") %>%
  filter(itemid %in% c(50912, 50971, 50983, 50902, 
                       50882, 51221, 51301, 50931)) %>%
  arrange(subject_id, charttime, itemid,) %>% 
  collect()
dbDisconnect(duckdb_conn)
```

```{r}
lab_items <- c(50912, 50971, 50983, 50902, 50882, 51221, 51301, 50931)  

labevents_filtered <- subset_labevents %>%
  inner_join(icustays_tble, by = "subject_id") %>%
  filter(storetime < intime) 

labevents_filtered <- labevents_filtered %>%
  mutate(valuenum = as.numeric(valuenum))

labevents_last <- labevents_filtered %>%
  group_by(subject_id, stay_id, itemid) %>%
  slice_max(order_by = storetime, n = 1, with_ties = FALSE) %>%  
  ungroup()

labevents_tble <- labevents_last %>%
  select(subject_id, stay_id, itemid, valuenum) %>%
  pivot_wider(names_from = itemid, values_from = valuenum)

colnames(labevents_tble) <- c("subject_id", "stay_id", "bicarbonate", "chloride", "creatinine",
                              "glucose", "potassium", "sodium", "hematocrit", "wbc")

labevents_tble <- labevents_tble %>%
  mutate(across(where(is.list), ~ as.numeric(unlist(.))))

cat("Data processing complete.\n")
print(head(labevents_tble)) 

```

## Q6. Vitals from charted events

`chartevents.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/icu/chartevents/>) contains all the charted data available for a patient. During their ICU stay, the primary repository of a patient’s information is their electronic chart. The `itemid` variable indicates a single measurement type in the database. The `value` variable is the value measured for `itemid`. The first 10 lines of `chartevents.csv.gz` are
```{bash}
zcat < ~/mimic/icu/chartevents.csv.gz | head
```

`d_items.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/icu/d_items/>) is the dictionary for the `itemid` in `chartevents.csv.gz`. 
```{bash}
zcat < ~/mimic/icu/d_items.csv.gz | head
```

We are interested in the vitals for ICU patients: heart rate (220045), systolic non-invasive blood pressure (220179), diastolic non-invasive blood pressure (220180), body temperature in Fahrenheit (223761), and respiratory rate (220210). Retrieve a subset of `chartevents.csv.gz` only containing these items for the patients in `icustays_tble`. Further restrict to the first vital measurement within the ICU stay. The final `chartevents_tble` should have one row per ICU stay and columns for each vital measurement. 

![](chartevents_tble.png)

**Solution ** It is important to note that I created a different chartevents_parquet file from the one in Homework #2. This is due to the fact that there is a dispreancy between the two homrwork (in homework #2, we collect data including mean non-invasive blood pressure: 220181 while in homework #3, we collect data including diastolic non-invasive blood pressure  220180). Presented below is the chartevents_pq file that includes information regarding diastolic non-invasive blood pressure (220180). 

```{r}
parquet_file <- "chartevents_pq/part-0.parquet"
start_time <- Sys.time()
arrow_data <- open_dataset(parquet_file, format = "parquet")
duckdb_conn <- dbConnect(duckdb::duckdb())

invisible(to_duckdb(
  .data = arrow_data,
  con = duckdb_conn,
  table_name = "chartevents",
  auto_disconnect = FALSE
))  

subset_chartevents <- tbl(duckdb_conn, "chartevents") %>%
  filter(itemid %in% c(220045, 220179, 220180, 223761, 220210)) %>%
  arrange(subject_id, charttime, itemid,) %>% 
  collect()

cat("Number of rows in the result:", nrow(subset_chartevents ), "\n")
print(head(subset_chartevents , 10)) 
dbDisconnect(duckdb_conn)
```

(delete later) retrieve a subset of chartevents.csv.gz only containing these items for patients in icystays_tble. 
more filter to the first vital measurement by store time within the ICU stay. 

Note: icustays_tble has 8 columns: subject_id, hadm_id, stay_id, first_careunit, last_careunit, intime, outtime, los 

```{r} 
icustays_tble
```


```{r} 
subset_chartevents 
```






Hint: Use the Parquet format you generated in Homework 2. For reproducibility, make `chartevents_pq` folder available at the current working directory, for example, by a symbolic link.

## Q7. Putting things together

Let us create a tibble `mimic_icu_cohort` for all ICU stays, where rows are all ICU stays of adults (age at `intime` >= 18) and columns contain at least following variables

- all variables in `icustays_tble`  
- all variables in `admissions_tble`  
- all variables in `patients_tble`
- the last lab measurements before the ICU stay in `labevents_tble` 
- the first vital measurements during the ICU stay in `chartevents_tble`

The final `mimic_icu_cohort` should have one row per ICU stay and columns for each variable.

![](mimic_icu_cohort.png)

```{r}
# Read the necessary data files
icustays_tble <- read_csv("~/mimic/icu/icustays.csv.gz")
admissions_tble <- read_csv("~/mimic/hosp/admissions.csv.gz")
patients_tble <- read_csv("~/mimic/hosp/patients.csv.gz")
labevents_tble <- read_parquet("./final_labevents.parquet")  # Preprocessed last lab values
chartevents_tble <- read_parquet("./chartevents_pq/part-0.parquet")  # First vitals

# Convert timestamps to POSIXct for proper filtering
icustays_tble <- icustays_tble %>%
  mutate(intime = ymd_hms(intime), outtime = ymd_hms(outtime))

admissions_tble <- admissions_tble %>%
  mutate(admittime = ymd_hms(admittime), dischtime = ymd_hms(dischtime))

patients_tble <- patients_tble %>%
  mutate(dod = ymd(dod))  # Convert date of death

# Filter ICU stays for adults (age >= 18 at intime)
mimic_icu_cohort <- icustays_tble %>%
  inner_join(patients_tble, by = "subject_id") %>%
  filter(anchor_age >= 18)  # Keep only adult patients

# Merge ICU stays with hospital admissions
mimic_icu_cohort <- mimic_icu_cohort %>%
  left_join(admissions_tble, by = c("subject_id", "hadm_id"))

# Merge with last lab values before ICU admission
mimic_icu_cohort <- mimic_icu_cohort %>%
  left_join(labevents_tble, by = c("subject_id", "stay_id"))

# Extract the first available vitals during ICU stay
chartevents_first_vitals <- chartevents_tble %>%
  filter(charttime >= intime) %>%  # Get vitals recorded after ICU admission
  group_by(stay_id, subject_id, itemid) %>%
  slice_min(order_by = charttime, n = 1) %>%  # Keep the first measurement
  ungroup() %>%
  select(subject_id, stay_id, itemid, value) %>%
  pivot_wider(names_from = itemid, values_from = value)

# Merge with first vitals
mimic_icu_cohort <- mimic_icu_cohort %>%
  left_join(chartevents_first_vitals, by = c("subject_id", "stay_id"))

# Arrange for better readability
mimic_icu_cohort <- mimic_icu_cohort %>%
  arrange(subject_id, stay_id)

# Save the final cohort
write_parquet(mimic_icu_cohort, "./mimic_icu_cohort.parquet")

# Display the first few rows
print(head(mimic_icu_cohort))

```


## Q8. Exploratory data analysis (EDA)

Summarize the following information about the ICU stay cohort `mimic_icu_cohort` using appropriate numerics or graphs:

- Length of ICU stay `los` vs demographic variables (race, insurance, marital_status, gender, age at intime)

- Length of ICU stay `los` vs the last available lab measurements before ICU stay

- Length of ICU stay `los` vs the first vital measurements within the ICU stay

- Length of ICU stay `los` vs first ICU unit


```{r}

```

