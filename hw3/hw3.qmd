---
title: "Biostat 203B Homework 3"
subtitle: "Due Feb 21 @ 11:59PM"
author: "Julie Lee, 806409381"
format:
  html:
    theme: cosmo
    embed-resources: true
    number-sections: false
    toc: true
    toc-depth: 4
    toc-location: left
    code-fold: false
---

Display machine information for reproducibility:
```{r}
sessionInfo()
```

Load necessary libraries (you can add more as needed).
```{r setup}
library(arrow)
library(gtsummary)
library(memuse)
library(pryr)
library(R.utils)
library(tidyverse)
```

Display your machine memory.
```{r}
memuse::Sys.meminfo()
```

In this exercise, we use tidyverse (ggplot2, dplyr, etc) to explore the [MIMIC-IV](https://physionet.org/content/mimiciv/3.1/) data introduced in [homework 1](https://ucla-biostat-203b.github.io/2025winter/hw/hw1/hw1.html) and to build a cohort of ICU stays.

## Q1. Visualizing patient trajectory

Visualizing a patient's encounters in a health care system is a common task in clinical data analysis. In this question, we will visualize a patient's ADT (admission-discharge-transfer) history and ICU vitals in the MIMIC-IV data.

### Q1.1 ADT history

A patient's ADT history records the time of admission, discharge, and transfer in the hospital. This figure shows the ADT history of the patient with `subject_id` 10001217 in the MIMIC-IV data. The x-axis is the calendar time, and the y-axis is the type of event (ADT, lab, procedure). The color of the line segment represents the care unit. The size of the line segment represents whether the care unit is an ICU/CCU. The crosses represent lab events, and the shape of the dots represents the type of procedure. The title of the figure shows the patient's demographic information and the subtitle shows top 3 diagnoses.

![](10001217_adt.png)
Do a similar visualization for the patient with `subject_id` 10063848 using ggplot.

Hint: We need to pull information from data files `patients.csv.gz`, `admissions.csv.gz`, `transfers.csv.gz`, `labevents.csv.gz`, `procedures_icd.csv.gz`, `diagnoses_icd.csv.gz`, `d_icd_procedures.csv.gz`, and `d_icd_diagnoses.csv.gz`. For the big file `labevents.csv.gz`, use the Parquet format you generated in Homework 2. For reproducibility, make the Parquet folder `labevents_pq` available at the current working directory `hw3`, for example, by a symbolic link. Make your code reproducible.

```{bash}
ln -s ~/biostat-203b-2025-winter/hw2/labevents_parquet ./labevents_pq
ls -l ./labevents_pq
```

```{r}
patients <- read_csv("~/mimic/hosp/patients.csv.gz")
admissions <- read_csv("~/mimic/hosp/admissions.csv.gz")
transfers <- read_csv("~/mimic/hosp/transfers.csv.gz")
labevents <- read_parquet("labevents_pq/part-0.parquet")
procedures <- read_csv("~/mimic/hosp/procedures_icd.csv.gz")
diagnoses <- read_csv("~/mimic/hosp/diagnoses_icd.csv.gz")
d_icd_procedures <- read_csv("~/mimic/hosp/d_icd_procedures.csv.gz")
d_icd_diagnoses <- read_csv("~/mimic/hosp/d_icd_diagnoses.csv.gz")
icustays <- read_csv("~/mimic/icu/icustays.csv.gz")
d_items <- read_csv("~/mimic/icu/d_items.csv.gz")
```



```{r}
# Filter data for patient 10063848
subject_id <- 10063848
patient_info <- patients %>% filter(subject_id == !!subject_id)
admissions_info <- admissions %>% filter(subject_id == !!subject_id)
transfers_info <- transfers %>% filter(subject_id == !!subject_id)
labevents_info <- labevents %>% filter(subject_id == !!subject_id)
procedures_info <- procedures %>% filter(subject_id == !!subject_id)
diagnoses_info <- diagnoses %>% filter(subject_id == !!subject_id)
d_icd_procedures_info <- d_icd_procedures %>% filter(subject_id == !!subject_id)
d_icd_diagnoses_info <- d_icd_diagnoses %>% filter(subject_id == !!subject_id)
icustays_info <- icustays %>% filter(subject_id == !!subject_id)
d_items_info <- d_items %>% filter(subject_id == !!subject_id)
```


```{r}
# Standardize ICD code format before merging
diagnoses_info <- diagnoses_info %>%
  mutate(icd_code = str_pad(icd_code, width = 5, pad = "0"))

# Merge diagnoses with descriptions
diagnoses_info <- diagnoses_info %>% 
  left_join(d_icd_diagnoses, by = c("icd_code", "icd_version"))

# Identify the correct long_title column for diagnoses
long_title_col <- grep("long_title", colnames(diagnoses_info), value = TRUE)

if ("long_title" %in% long_title_col) {
  diagnoses_info <- diagnoses_info %>% rename(diagnosis_name = long_title)
} else if ("long_title.x" %in% long_title_col) {
  diagnoses_info <- diagnoses_info %>% rename(diagnosis_name = long_title.x)
} else if ("long_title.y" %in% long_title_col) {
  diagnoses_info <- diagnoses_info %>% rename(diagnosis_name = long_title.y)
} else {
  stop("long_title column not found in diagnoses_info")
}

# Extract top 3 diagnoses, removing NA values
top_diagnoses <- diagnoses_info %>% 
  filter(!is.na(diagnosis_name)) %>% 
  count(diagnosis_name, sort = TRUE) %>%  
  slice_head(n = 3) %>% 
  pull(diagnosis_name)

# Format diagnoses for display
top_diagnoses_text <- ifelse(length(top_diagnoses) > 0,
  paste(top_diagnoses, collapse = "\n"), "")

# Construct patient summary
patient_summary <- str_squish(str_c(
  "Patient ", patient_info, ", ",
  case_when(is.na(patient_info$gender) ~ "", TRUE ~ str_c(patient_info$gender, ", ")),
  case_when(is.na(patient_info$anchor_age) ~ "", TRUE ~ str_c(patient_info$anchor_age, " years old, ")),
  case_when(is.na(admissions_info$race) ~ "", TRUE ~ admissions_info$race)
))

# Convert timestamps
transfers_info <- transfers_info %>%
  mutate(intime = as.POSIXct(intime, format="%Y-%m-%d %H:%M:%S"),
         outtime = as.POSIXct(outtime, format="%Y-%m-%d %H:%M:%S")) %>%
  filter(!is.na(outtime))  

labevents_info <- labevents_info %>%
  mutate(chartdate = as.POSIXct(charttime, format="%Y-%m-%d %H:%M:%S"))

# Join and resolve duplicate columns in procedures_info
procedures_info <- procedures_info %>%
  mutate(chartdate = as.POSIXct(chartdate, format="%Y-%m-%d %H:%M:%S")) %>%
  left_join(d_icd_procedures, by = c("icd_code", "icd_version"))

# Identify procedure name columns
procedure_name_cols <- grep("long_title", colnames(procedures_info), value = TRUE)

# Ensure only one unique procedure_name remains
if (length(procedure_name_cols) > 1) {
  procedures_info <- procedures_info %>% 
  select(-one_of(procedure_name_cols[-1])) %>% 
  rename(procedure_name = procedure_name_cols[1])
} else if (length(procedure_name_cols) == 1) {
  procedures_info <- procedures_info %>%
  rename(procedure_name = procedure_name_cols[1])
} else {
  stop("procedure_name column not found in procedures_info")
}

# Remove rows where procedure_name is missing
procedures_info <- procedures_info %>% filter(!is.na(procedure_name))

### **Dynamically Extract Unique Care Units** ###
unique_care_units <- unique(transfers_info$careunit)

# Dynamically generate colors for care units
care_unit_colors <- setNames(
  RColorBrewer::brewer.pal(n = min(length(unique_care_units), 9), name = "Set1"),  
  unique_care_units
)

# Ensure Care Unit Column is a Factor with Correct Levels
transfers_info <- transfers_info %>%
  mutate(careunit = factor(careunit, levels = unique_care_units))  

### **Dynamically Extract Unique Procedures** ###
unique_procedures <- unique(procedures_info$procedure_name)

# Ensure Procedures Have Unique Shapes
procedure_shapes <- setNames(
  seq(15, 15 + length(unique_procedures) - 1),
  unique_procedures
)

procedures_info <- procedures_info %>%
  mutate(procedure_name = factor(procedure_name, levels = unique_procedures))

# Debugging: Print extracted care units and procedures
print("Unique Care Units:"); print(unique_care_units)
print("Unique Procedures:"); print(unique_procedures)

### **Plot Patient Trajectory** ###
plot <- ggplot() +
  geom_segment(data = transfers_info, 
               aes(x = intime, xend = outtime,
                   y = "ADT", yend = "ADT", color = careunit), 
               linewidth = 3) +
  geom_point(data = labevents_info, 
             aes(x = chartdate, y = "Lab"), shape = 3, size = 3) +
  geom_point(data = procedures_info, 
             aes(x = chartdate, y = "Procedure", shape = procedure_name), size = 5) +
  scale_color_manual(values = care_unit_colors) +  
  scale_shape_manual(values = procedure_shapes, drop = FALSE) + 
  scale_y_discrete(limits = c("Procedure", "Lab", "ADT")) +  
  theme_minimal() +
  labs(title = patient_summary, 
       subtitle = top_diagnoses_text, 
       x = "Calendar Time", 
       y = NULL, 
       color = "Care Unit", 
       shape = "Procedure") +
  guides(
    color = guide_legend(order = 1, title.position = "top"),  
    shape = guide_legend(order = 2, title.position = "top")   
  ) +
  theme(
    legend.position = "bottom",
    legend.box = "vertical",
    legend.box.just = "center",
    legend.spacing.y = unit(0.5, "cm"),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 10)
  )

print(plot)


```




**1.2** 


```{r}

```




```{r}
## Q2. ICU stays
`icustays.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/icu/icustays/>) contains data about Intensive Care Units (ICU) stays. The first 10 lines are
```{bash}
zcat < ~/mimic/icu/icustays.csv.gz | head
```

### Q2.1 Ingestion

Import `icustays.csv.gz` as a tibble `icustays_tble`. **Done** 

```{r}
icustays_tble <- read_csv("~/mimic/icu/icustays.csv.gz")
head(icustays_tble)
```

### Q2.2 Summary and visualization

How many unique `subject_id`? Can a `subject_id` have multiple ICU stays? Summarize the number of ICU stays per `subject_id` by graphs. 

**(2.2) Solution ** 

The number of unique subject_id there are in the (icustays_tble) tibble is 65366 unique subjects. 
```{r}
# Count unique subject_id
num_unique_subjects <- icustays_tble %>% 
  distinct(subject_id) %>% 
  nrow()

print(paste(num_unique_subjects))
```

A subject_id can have multiple ICU stays. We first obtained a tibble with the number of ICU stays per subject_id. Next we filtered out the rows where the subjects only had 1 ICU stay and counted the number of remaining rows. The number of patients with multiple ICU stays is 16242. 

```{r}
icu_stays_per_subject <- icustays_tble %>% 
  count(subject_id, name = "num_stays")

num_multiple_stays <- icu_stays_per_subject %>%
  filter(num_stays > 1) %>%
  nrow()

print(paste(num_multiple_stays))
```

The number of ICU stays per 'subject_id' is shown through the following graphs: 
We are able to see that 
Range of ICU stays is 1-41 stays. 

```{r}
# Summarize ICU stays per subject_id efficiently
icu_stays_summary <- icustays_tble %>%
  group_by(subject_id) %>%
  summarise(num_stays = n(), .groups = 'drop')

top_patients <- icu_stays_summary %>%
  arrange(desc(num_stays)) %>%
  head(20)

ggplot(top_patients, aes(x = reorder(subject_id, num_stays), y = num_stays)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(title = "Top 20 Patients with Most ICU Stays",
       x = "Subject ID",
       y = "Number of ICU Stays") +
  theme_minimal()
```

```{r}
ggplot(icu_stays_summary, aes(x = subject_id, y = num_stays)) +
  geom_jitter(color = "blue", alpha = 0.5, width = 0.3) +
  labs(title = "ICU Stays per Subject",
       x = "Unique Subject ID",
       y = "Number of ICU Stays") +
  theme_minimal()
```
```{r}
# Summarize ICU stays per subject_id
icu_stays_summary <- icustays_tble %>%
  group_by(subject_id) %>%
  summarise(num_stays = n(), .groups = 'drop')

# Define 5 groups based on ICU stay ranges
icu_stays_summary <- icu_stays_summary %>%
  mutate(stay_group = case_when(
    num_stays >= 1  & num_stays <= 8  ~ "1-8 stays",
    num_stays >= 9  & num_stays <= 16 ~ "9-16 stays",
    num_stays >= 17 & num_stays <= 24 ~ "17-24 stays",
    num_stays >= 25 & num_stays <= 32 ~ "25-32 stays",
    num_stays >= 33 & num_stays <= 41 ~ "33-41 stays"
  ))

# Order data by number of stays for better visualization
icu_stays_summary <- icu_stays_summary %>%
  arrange(num_stays)

# Assign numeric index for x-axis
icu_stays_summary <- icu_stays_summary %>%
  mutate(patient_index = row_number())

# Plot: Color-coded scatter plot of patients by ICU stay group
ggplot(icu_stays_summary, aes(x = patient_index, y = num_stays, color = stay_group)) +
  geom_point(alpha = 0.6, size = 2) + 
  labs(title = "ICU Stays per Subject (Grouped by Number of Stays)",
       x = "Patients (Sorted by ICU Stays)",
       y = "Number of ICU Stays",
       color = "ICU Stay Group") +
  theme_minimal() +
  scale_color_manual(values = c("blue", "green", "orange", "red", "purple"))
```


```{r}
# Summarize ICU stays per subject_id
icu_stays_summary <- icustays_tble %>%
  group_by(subject_id) %>%
  summarise(num_stays = n(), .groups = 'drop')

# Define 5 groups based on ICU stay ranges
icu_stays_summary <- icu_stays_summary %>%
  mutate(stay_group = case_when(
    num_stays >= 1  & num_stays <= 8  ~ "1-8 stays",
    num_stays >= 9  & num_stays <= 16 ~ "9-16 stays",
    num_stays >= 17 & num_stays <= 24 ~ "17-24 stays",
    num_stays >= 25 & num_stays <= 32 ~ "25-32 stays",
    num_stays >= 33 & num_stays <= 41 ~ "33-41 stays"
  ))

# Plot: Color-coded scatter plot of patients by ICU stay group (keeping original subject_id order)
ggplot(icu_stays_summary, aes(x = subject_id, y = num_stays, color = stay_group)) +
  geom_point(alpha = 0.6, size = 2) + 
  labs(title = "ICU Stays per Subject (Using Subject ID on X-Axis)",
       x = "Subject ID",
       y = "Number of ICU Stays",
       color = "ICU Stay Group") +
  theme_minimal() +
  scale_color_manual(values = c("blue", "green", "orange", "red", "purple"))  # Assigning colors

```

## Q3. `admissions` data

Information of the patients admitted into hospital is available in `admissions.csv.gz`. See <https://mimic.mit.edu/docs/iv/modules/hosp/admissions/> for details of each field in this file. The first 10 lines are

```{bash}
zcat < ~/mimic/hosp/admissions.csv.gz | head
```

### Q3.1 Ingestion

Import `admissions.csv.gz` as a tibble `admissions_tble`. **Done** 

```{r}
admissions_tble <- read_csv("~/mimic/hosp/admissions.csv.gz")
print(admissions_tble)
```

**(3.1 Solution) ** The admission_tble tibble has 546,028 rows and 16 columns. 

### Q3.2 Summary and visualization

Summarize the following information by graphics and explain any patterns you see.

1. Number of admissions per patient 

**Analysis:** The histogram represents the distribution of hospital admissions per patient on a log scale. The x-axis, which was log-transformed represents the number of admissions per patient while the y-axis represents the number of patients. We are able to see from the histogram that the majority of patients have only 1-3 admissions, but a few patients have significantly higher admission counts. A small subset of patients have 10+ admissions, with some extreme cases exceeding 200 admissions. 

```{r}
admissions_summary <- admissions_tble %>%
  group_by(subject_id) %>%
  summarise(num_admissions = n(), .groups = 'drop')

# Histogram with more bins and improved log scale
ggplot(admissions_summary, aes(x = num_admissions)) +
  geom_histogram(binwidth = 0.5, fill = "steelblue", color = "black", alpha = 0.8) +  # Smaller bin width
  scale_x_continuous(trans = "log1p", breaks = c(1, 2, 3, 5, 10, 15, 20, 30, 50, 100, 200)) +  # Finer x-axis detail
  labs(title = "Distribution of Admissions per Patient",
       x = "Number of Admissions (Log Scale)",
       y = "Number of Patients") +
  theme_minimal()
```

2. Admission hour (anything unusual?)  

**Analysis ** 
There is a high sharp spike at Midnight (00:00) which is likely not a true clinical pattern by rather an artifact of hospital data entry practices, such as batch processing of admissions at the start of a new day. The second peak occurs around 7-8 AM which may reflect morning clinical assessments leading to ICU transfers. Admissions then gradually rise throughout the day, peaking between 4-8 PM. 

```{r}
admissions_tble <- admissions_tble %>%
  mutate(admit_hour = hour(admittime))  # Extract hour from POSIXct datetime

ggplot(admissions_tble, aes(x = admit_hour)) +
  geom_histogram(binwidth = 1, fill = "steelblue", color = "black", alpha = 0.8) +
  scale_x_continuous(breaks = seq(0, 23, by = 1)) +  # Ensure all hours are visible
  labs(title = "Distribution of ICU Admissions by Hour",
       x = "Hour of Admission (24-hour format)",
       y = "Number of Admissions") +
  theme_minimal()
```

3. Admission minute (anything unusual?)  

**Analysis:** 
The histogram displays the distriution of ICU admission by the minute of the hour (0-59). There are sharp pikes in admissions at minutes 0,15,30,and 45 minutes, which are significantly higher than the other minutes. This suggests that admissions are often recorded at roudned times rather than exact times when paitnets arrive. This pattern is unlikely because there would be natural variations in patient arrivals. Instead, it could be a result of the hospital staff rounding admission times when entering data. Apart from the spikes, the distribution across other minutes is relatively uniform, signifying that the real admission times likely occur throughout the hou but are being recorded in a biased manner. 

```{r}
admissions_tble <- admissions_tble %>%
  mutate(admit_minute = minute(admittime))  # Extract minute from POSIXct datetime

ggplot(admissions_tble, aes(x = admit_minute)) +
  geom_histogram(binwidth = 1, fill = "darkorange", color = "black", alpha = 0.8) +
  scale_x_continuous(breaks = seq(0, 59, by = 5)) +  # Ensure visibility for all minutes
  labs(title = "Distribution of ICU Admissions by Minute",
       x = "Minute of Admission (0-59)",
       y = "Number of Admissions") +
  theme_minimal()
```

4. Length of hospital stay (from admission to discharge) (anything unusual?)  

**Analysis** 
There 

```{r}
# Focus on hospital stays of 30 days or less
short_stays <- admissions_tble %>%
  filter(length_of_stay <= 30)

# Refined histogram with density overlay
ggplot(short_stays, aes(x = length_of_stay)) +
  geom_histogram(binwidth = 1, fill = "steelblue", color = "black", alpha = 0.8) +
  geom_density(color = "red", size = 1, alpha = 0.6) +
  scale_x_continuous(breaks = seq(0, 30, by = 5)) +
  labs(title = "Refined Distribution of Hospital Length of Stay (≤ 30 Days)",
       x = "Length of Stay (Days)",
       y = "Number of Patients") +
  theme_minimal()

```

```{r}
# Filter for patients with very long stays (>30 days)
long_stay_patients <- admissions_tble %>%
  filter(length_of_stay > 30)

# Summary statistics for long-stay patients
summary(long_stay_patients$length_of_stay)

# Histogram of long stays
ggplot(long_stay_patients, aes(x = length_of_stay)) +
  geom_histogram(binwidth = 5, fill = "red", color = "black", alpha = 0.8) +
  scale_x_continuous(breaks = seq(30, max(long_stay_patients$length_of_stay, na.rm = TRUE), by = 10)) +
  labs(title = "Distribution of Patients with Long Hospital Stays (>30 Days)",
       x = "Length of Stay (Days)",
       y = "Number of Patients") +
  theme_minimal()
```


According to the [MIMIC-IV documentation](https://mimic.mit.edu/docs/iv/about/concepts/#date-shifting), 

> All dates in the database have been shifted to protect patient confidentiality. Dates will be internally consistent for the same patient, but randomly distributed in the future. Dates of birth which occur in the present time are not true dates of birth. Furthermore, dates of birth which occur before the year 1900 occur if the patient is older than 89. In these cases, the patient’s age at their first admission has been fixed to 300.

## Q4. `patients` data

Patient information is available in `patients.csv.gz`. See <https://mimic.mit.edu/docs/iv/modules/hosp/patients/> for details of each field in this file. The first 10 lines are
```{bash}
zcat < ~/mimic/hosp/patients.csv.gz | head
```

### Q4.1 Ingestion

Import `patients.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/hosp/patients/>) as a tibble `patients_tble`.

```{r}
patients_tble <- read_csv("~/mimic/hosp/patients.csv.gz")
print(patients_tble)
```
### Q4.2 Summary and visualization

Summarize variables `gender` and `anchor_age` by graphics, and explain any patterns you see.

gender, the genotypical sex of the patient. 
anchor_age is the patient's age in the anchor_year. If a patient's anchor_age is over 89 in the anchor_year then their ancho_age is set to 91, regardless of how old they actually are. 

Gender: 
```{r}
# Bar Plot: Gender Distribution with Custom Colors
ggplot(patients_tble, aes(x = gender, fill = gender)) +
  geom_bar(color = "black", alpha = 0.8) +
  scale_fill_manual(values = c("M" = "steelblue", "F" = "pink")) +  # Assign colors
  labs(title = "Gender Distribution",
       x = "Gender",
       y = "Count of Patients") +
  theme_minimal()

```

Anchor_age: 
```{r}
# 2. Histogram: Age Distribution
ggplot(patients_tble, aes(x = anchor_age)) +
  geom_histogram(binwidth = 5, fill = "steelblue", color = "black", alpha = 0.8) +
  labs(title = "Age Distribution of Patients",
       x = "Age (Years)",
       y = "Number of Patients") +
  theme_minimal()
```

Combining the 2 variables together: Gender and Anchor_Age: 
```{r}
# 3. Box Plot: Age by Gender
ggplot(patients_tble, aes(x = gender, y = anchor_age, fill = gender)) +
  geom_boxplot(alpha = 0.8) +
  labs(title = "Age Distribution by Gender",
       x = "Gender",
       y = "Age (Years)") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "pink"))  # Custom colors for M & F
```
## Q5. Lab results

`labevents.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/hosp/labevents/>) contains all laboratory measurements for patients. The first 10 lines are

```{bash}
zcat < ~/mimic/hosp/labevents.csv.gz | head
```

`d_labitems.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/hosp/d_labitems/>) is the dictionary of lab measurements. 
```{bash}
zcat < ~/mimic/hosp/d_labitems.csv.gz | head
```

We are interested in the lab measurements of creatinine (50912), potassium (50971), sodium (50983), chloride (50902), bicarbonate (50882), hematocrit (51221), white blood cell count (51301), and glucose (50931). Retrieve a subset of `labevents.csv.gz` that only containing these items for the patients in `icustays_tble`. Further restrict to the last available measurement (by `storetime`) before the ICU stay. The final `labevents_tble` should have one row per ICU stay and columns for each lab measurement.

![](labevents_tble.png)
We will use the Parquet format that I generated in Homework #2. For reproducibility, the labevents_pq folder is available at the current working directory by a symbolic link: 

```{bash}
ls -l ./labevents_pq
```

Hint: Use the Parquet format you generated in Homework 2. For reproducibility, make `labevents_pq` folder available at the current working directory `hw3`, for example, by a symbolic link.

```{r}
# Read the Parquet file
labevents_tble <- read_parquet("./labevents_pq/part-0.parquet")
head(labevents_tble)
```


```{r}
dlabitems_tble <- dlabitems_tble %>%
  mutate(itemid = as.integer(itemid))
str(dlabitems_tble)
```

```{r}
 dlabitems_tble <- read_csv ("~/mimic/hosp/d_labitems.csv.gz")

# Read in lab events data file
open_dataset(sources = "./labevents_pq/part-0.parquet",
             format = "parquet") |>
# create a virtual table in DuckDB
to_duckdb() |>
# select the columns
select(subject_id, itemid, storetime, valuenum) |>
# restrict to itemid of interest
filter(itemid %in% local(dlabitems_tble$itemid)) |>
# pull in the intime of ICU stays, copy = TRUE to avoid modifying the original table
left_join(
    select(icustays_tble, subject_id, stay_id, intime),
    by = c("subject_id"),
    copy = TRUE) |>
# only keep lab items available to provider before this ICU stay
filter(storetime < intime) |>
# group by subject_id and itemid
group_by(subject_id, stay_id, itemid) |>
# only keep the last lab value before ICU stay
slice_max(storetime, n = 1) |>
# do not need storetime and intime
select(-storetime, -intime) |>
ungroup() |>
pivot_wider(names_from = itemid, values_from = valuenum) |>
# readable column names
rename_at(
    vars(as.character(dlabitems_tble$itemid)),
    ~ str_to_lower(dlabitems_tble$itemid)
) |>
# force computation
collect() |>
# sort for grading purposes
arrange(subject_id, stay_id) |>
relocate(subject_id, stay_id, sort(names(.))) 
```


## Q6. Vitals from charted events

`chartevents.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/icu/chartevents/>) contains all the charted data available for a patient. During their ICU stay, the primary repository of a patient’s information is their electronic chart. The `itemid` variable indicates a single measurement type in the database. The `value` variable is the value measured for `itemid`. The first 10 lines of `chartevents.csv.gz` are
```{bash}
zcat < ~/mimic/icu/chartevents.csv.gz | head
```

`d_items.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/icu/d_items/>) is the dictionary for the `itemid` in `chartevents.csv.gz`. 
```{bash}
zcat < ~/mimic/icu/d_items.csv.gz | head
```

We are interested in the vitals for ICU patients: heart rate (220045), systolic non-invasive blood pressure (220179), diastolic non-invasive blood pressure (220180), body temperature in Fahrenheit (223761), and respiratory rate (220210). Retrieve a subset of `chartevents.csv.gz` only containing these items for the patients in `icustays_tble`. Further restrict to the first vital measurement within the ICU stay. The final `chartevents_tble` should have one row per ICU stay and columns for each vital measurement. 

![](chartevents_tble.png)


Ingesting the file: chartevents.csv.gz 

```{r}
# Read the CSV file (handling compressed .gz format)
labevents_tble <- read_csv("labevents.csv.gz")

# Convert timestamps to POSIXct (datetime) format
labevents_tble <- labevents_tble %>%
  mutate(storetime = parse_date_time(storetime, orders = c("ymd HMS", "ymd")))

# Save as Parquet format
write_parquet(labevents_tble, "labevents.parquet")

# Verify that the Parquet file is created correctly
print(head(labevents_tble))
```

Hint: Use the Parquet format you generated in Homework 2. For reproducibility, make `chartevents_pq` folder available at the current working directory, for example, by a symbolic link.

## Q7. Putting things together

Let us create a tibble `mimic_icu_cohort` for all ICU stays, where rows are all ICU stays of adults (age at `intime` >= 18) and columns contain at least following variables

- all variables in `icustays_tble`  
- all variables in `admissions_tble`  
- all variables in `patients_tble`
- the last lab measurements before the ICU stay in `labevents_tble` 
- the first vital measurements during the ICU stay in `chartevents_tble`

The final `mimic_icu_cohort` should have one row per ICU stay and columns for each variable.

![](mimic_icu_cohort.png)

```{r}
# Read the necessary data files
icustays_tble <- read_csv("~/mimic/icu/icustays.csv.gz")
admissions_tble <- read_csv("~/mimic/hosp/admissions.csv.gz")
patients_tble <- read_csv("~/mimic/hosp/patients.csv.gz")
labevents_tble <- read_parquet("./final_labevents.parquet")  # Preprocessed last lab values
chartevents_tble <- read_parquet("./chartevents_pq/part-0.parquet")  # First vitals

# Convert timestamps to POSIXct for proper filtering
icustays_tble <- icustays_tble %>%
  mutate(intime = ymd_hms(intime), outtime = ymd_hms(outtime))

admissions_tble <- admissions_tble %>%
  mutate(admittime = ymd_hms(admittime), dischtime = ymd_hms(dischtime))

patients_tble <- patients_tble %>%
  mutate(dod = ymd(dod))  # Convert date of death

# Filter ICU stays for adults (age >= 18 at intime)
mimic_icu_cohort <- icustays_tble %>%
  inner_join(patients_tble, by = "subject_id") %>%
  filter(anchor_age >= 18)  # Keep only adult patients

# Merge ICU stays with hospital admissions
mimic_icu_cohort <- mimic_icu_cohort %>%
  left_join(admissions_tble, by = c("subject_id", "hadm_id"))

# Merge with last lab values before ICU admission
mimic_icu_cohort <- mimic_icu_cohort %>%
  left_join(labevents_tble, by = c("subject_id", "stay_id"))

# Extract the first available vitals during ICU stay
chartevents_first_vitals <- chartevents_tble %>%
  filter(charttime >= intime) %>%  # Get vitals recorded after ICU admission
  group_by(stay_id, subject_id, itemid) %>%
  slice_min(order_by = charttime, n = 1) %>%  # Keep the first measurement
  ungroup() %>%
  select(subject_id, stay_id, itemid, value) %>%
  pivot_wider(names_from = itemid, values_from = value)

# Merge with first vitals
mimic_icu_cohort <- mimic_icu_cohort %>%
  left_join(chartevents_first_vitals, by = c("subject_id", "stay_id"))

# Arrange for better readability
mimic_icu_cohort <- mimic_icu_cohort %>%
  arrange(subject_id, stay_id)

# Save the final cohort
write_parquet(mimic_icu_cohort, "./mimic_icu_cohort.parquet")

# Display the first few rows
print(head(mimic_icu_cohort))

```


## Q8. Exploratory data analysis (EDA)

Summarize the following information about the ICU stay cohort `mimic_icu_cohort` using appropriate numerics or graphs:

- Length of ICU stay `los` vs demographic variables (race, insurance, marital_status, gender, age at intime)

- Length of ICU stay `los` vs the last available lab measurements before ICU stay

- Length of ICU stay `los` vs the first vital measurements within the ICU stay

- Length of ICU stay `los` vs first ICU unit


```{r}

```

